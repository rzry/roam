#+TITLE:     mysql查询
#+AUTHOR:    rzry
#+EMAIL:     rzry36008@ccie.lol
#+DATE:      2020-09-16
#+LANGUAGE:  en
#+OPTIONS:   H:4 num:nil toc:2
#+SETUPFILE: ../../org-html-themes/setup/theme-readtheorg.setup
#+begin_export html
<div class="right">
<a href="https://github.com/rzry" class="fa fa-github"> Edit on GitHub</a>
</div>
#+end_export


* 基础查询
#+BEGIN_SRC 
# 进阶1 : 基础查询 
/* 
语法 : 
select 查询列表
 from 表名;
*/
use myemployees;
# 查询表中的单个字段 
select job_id 
from jobs;

select last_name 
from employees;

# 查询多个字段 
select last_name,first_name,email
 from employees;
 
# 查询所有字段 
select * 
from employees;

#  查询常量值  
select 100;
select 'ks';

#查询表达式 
select 100%98;

#查询函数 
select Version();

#起别名 
 #方式一
select 100%98 as 结果;
select last_name as 姓 ,first_name as 名 
from employees;

#方式二  空格 
select last_name 姓 ,first_name 名
from employees;
# 案例  查询 salary  让他显示结果为 out put  (有空格 )
select salary as "out put"
from employees;

# 8 . 去重  //distinct 
# 案例 查询员工表中设计到的所有的部门编号
 select distinct department_id
from employees;

#9  + 的作用 
/* 
mysql 中 加 号 只有一个 功能 就是 运算符 
select 100+30;
select '123'+30;
select 'ggg'+60; 如果不能将字符值转换程数值 那么就把字符型转换成0
select null+10;  只要一个是null  结果就是 null 
*/
#  查询 员工的 姓 和名  显示成姓名  
select concat(last_name,first_name) as 结果
from employees;


# 案例  显示表 employees 的全部列 , 各个列之间用逗号隔开 ,列头显示为 out_put

##  新知识  判断是否为 null   是null  就给个值  0 

select ifnull(`commission_pct`,0) as 奖金率,
		commission_pct
from employees;

select concat(`employee_id`,  ','  ,`first_name`,  ','   ,`last_name`,  ',' , `email`,  ','  ,ifnull(commission_pct,0))  as out_put
from employees;

#+END_SRC
* 条件查询
#+BEGIN_SRC 
# 条件查询 
/* 
语法  : 
		select  查询列表 
		from  表名 
		where 筛选条件 ; 
        
        分类 :
		1 . 按条件表达式筛选 
         条件运算符   ;  >  <  = !=  <>  >=  <= 
		2 . 按逻辑表达式筛选 
        作用 :  用于链接条件表达式
        逻辑运算符  : 
			&& ||  ! 
            and or not 
            
            && 和and  两个都为真 结果为true 
            || 和 or  有一个为真 结果为 true 
            ! 和 not  本身为真 结果为flase 
		3 . 模糊查询 
			like 
            between and 
            in 
            is null 
 */
 
 #1  按条件表达式 筛选 
# 案例1 查询 工资> 12000 的 员工信息  	
	select * 
	from  employees
	where  salary > 12000;
# 查询 部门编号 不等于90 的员工名 和部门编号

	select last_name,department_id
	from employees 
	where department_id<>90;

# 2  按逻辑表达式筛选 
 # 案例1  查询工资在 10000 到20000 之间的 员工名 . 工资 以及奖金 
	 select last_name,salary,commission_pct
	 from 
	 where salary >= 10000 and salary <= 20000;
# 案例2  部门编号不是在 90 到 110 之间或者 工资高于15000 的员工信息 
	select * 
	from employees
	where department_id < 90 or department_id > 110 or salary >15000;

# 3  模糊查询  

#查询 名字中 有 a 的员工信息
	select * 
	from employees
	where last_name like '%a%';
# 查询 员工名中 第三个字符为 n 第五个字符为 l 的员工名 和工资 
	select last_name,salary
	from employees
	where last_name like '__n_l%';
# 查询 员工名中 第二个字符为 _ 的员工名 
	select last_name 
	from employees
	where last_name like '_\_%';
# 可以转义  如果想自定义转义  
	# last_name like '_$_% escape '$'';
    
# between and  
/*
	 between and  包含临界值 
     不能调换顺序  
*/
 # 案例 1  员工编号在 100 到 120 之间的 员工信息 
	select * 
	from employees
	where employee_id between 100 and 120;

#  in 

/*
  含义 :  判断 某字段的值 是否属于in 列表中的 某一项 
  特点 :  in 列表的 值类型 必须一致 或者 兼容 
*/

34 
	# 查询员工的工种编号 是 ad_vp , AD_PRES 中的一个员工名和工种编号
	    select last_name,job_id
	    from employees
	    where job_id in ('AD_VP','AD_PRES');

# is null 
	
# 案例1  查询 没有奖金的员工名和奖金率  
	    select commission_pct,last_name
	    from employees 
	    where commission_pct is null

# 安全等于 <=>
	  select commission_pct,salary
		 from employees 
		 where salary <=> 12000

# is null pk <=>
is null : 仅仅可以判断null值 可读性比较高 
<=> : 既可以判断null值 又可以判断普通的数值, 可读性低 (不推荐)

# 练习题  ----------------------------------------------------------------------

#1. 查询工资大于 12000 的员工姓名和工资
		select last_name,first_name as 姓名 ,salary as 工资 
		from employees
		where salary > 12000;
#2. 查询员工号为 176 的员工的姓名和部门号和年薪
#(我先做的 )
		select last_name,first_name as 姓名 ,department_id,salary*12
		from employees 
		where employee_id <=> 176
#(老师做的 )
		select last_name,first_name as 姓名 ,
				department_id,
				salary*12*(1+ifnull(commission_pct,0))as 年薪
		from employees 
		where employee_id <=> 176
#3. 选择工资不在 5000 到 12000 的员工的姓名和工资

		select first_name,last_name as 姓名,
				salary
		from employees
		where salary < 5000 or salary>12000
#4. 选择在 20 或 50 号部门工作的员工姓名和部门号
		select last_name as 姓名,
				department_id
		from employees
		where department_id in (20,50)
#5. 选择公司中没有管理者的员工姓名及 job_id
		select last_name as 姓名,
				job_id
		from employees 
		where  manager_id is null;
			
#6. 选择公司中有奖金的员工姓名，工资和奖金级别
		select last_name,
			salary,
			ifnull(commission_pct,0)
		from employees
		where commission_pct > 0.2 #(这边要求奖金级别,我不知道怎么分)
#7. 选择员工姓名的第三个字母是 a 的员工姓名
		select last_name as 姓名
		from employees
		where last_name like '__a%';
#8. 选择姓名中有字母 a 和 e 的员工姓名
		select last_name as 姓名 
		from employees
		where last_name like '%a%' or '%e%';
#9. 显示出表 employees 表中 first_name 以 'e'结尾的员工信息
		select first_name
		from employees
		where first_name like '%e'

#10. 显示出表 employees 部门编号在 80-100 之间 的姓名、职位
		select last_name,department_id
		from employees
		where department_id between 80 and 100

#11. 显示出表 employees 的 manager_id 是 100,101,110 的员工姓名、职位
		select last_name,department_id
		from employees
		where manager_id in (100,101,110)


#目前是第37节结束

#+END_SRC
* 排序查询
#+BEGIN_SRC 
# 进阶3 排序查询 
#引入
select * 
from employees

/* 语法  
	select 查询列表 
	    from 表 
	    [where 条件]
	    order by 排序列表 [asc | desc ]
    		*/
   	# 2、order by子句可以支持 单个字段、别名、表达式、函数、多个字段

	#3、order by子句在查询语句的最后面，除了limit子句
#
#案例1、按单个字段排序
	SELECT * FROM employees ORDER BY salary asc;
#2、添加筛选条件再排序

#案例2：查询部门编号>=90的员工信息，并按员工编号降序

	SELECT *
	FROM employees
	WHERE department_id>=90
	ORDER BY employee_id DESC;
#3、按表达式排序
#案例：查询员工信息 按年薪降序


	SELECT *,salary*12*(1+IFNULL(commission_pct,0))
	FROM employees
	ORDER BY salary*12*(1+IFNULL(commission_pct,0)) DESC;


#4、按别名排序
#案例：查询员工信息 按年薪升序

	SELECT *,salary*12*(1+IFNULL(commission_pct,0)) 年薪
	FROM employees
	ORDER BY 年薪 ASC;
#5、按函数排序
#案例：查询员工名，并且按名字的长度降序

	SELECT LENGTH(last_name),last_name 
	FROM employees
	ORDER BY LENGTH(last_name) DESC;

#6、按多个字段排序

#案例：查询员工信息，要求先按工资降序，再按employee_id升序
	 SELECT *
	FROM employees
	ORDER BY salary DESC,employee_id ASC;

# 练习 
#1. 查询员工的姓名和部门号和年薪，按年薪降序 按姓名升序
	select last_name 姓名 , department_id,salary*12*(1+ifnull(commission_pct,0)) as 年薪 
	from employees
	order by 年薪 desc,姓名 asc
2. 选择工资不在 8000 到 17000 的员工的姓名和工资，按工资降序
	select last_name,salary
	from employees
	where salary < 8000 or salary > 17000  # not between 8000 and 17000
	order by salary desc
3. 查询邮箱中包含 e 的员工信息，并先按邮箱的字节数降序，再按部门号升序
	select * 
	from employees
	where email like '%e%'
	order by LENGTH(email) desc,employee_id asc



#查询员工号，姓名，工资，以及工资提高百分之 20%后的结果（new salary）

	select employee_id,last_name,salary 旧工资,salary*(1+0.2) 新工资
	from employees
#将员工的姓名按首字母排序，并写出姓名的长度（length）
	select last_name,length(last_name),substr(last_name,1,1) 首字符
    from employees
    order by 首字符


#做一个查询，产生下面的结果
#<last_name> earns <salary> monthly but wants <salary*3>
#Dream Salary
#King earns 24000 monthly but wants 72000

	select last_name,salary 工资,salary * 3 期望工资    # 我做的 全错  

	select concat( last_name ,'earns',salary,'monthly but wants',salary*3)as "Dream Salary"
	from employees
	where salary = 24000

#+END_SRC
* 常见函数
#+BEGIN_SRC 
/*

概念：类似于java的方法，将一组逻辑语句封装在方法体中，对外暴露方法名
好处：1、隐藏了实现细节  2、提高代码的重用性
调用：select 函数名(实参列表) 【from 表】;
特点： 
	①叫什么（函数名）
	②干什么（函数功能）

分类：
	1、单行函数
	如 concat、length、ifnull等
	2、分组函数
	
	功能：做统计使用，又称为统计函数、聚合函数、组函数
	
常见函数：
	一、单行函数
	字符函数：
	length:获取字节个数(utf-8一个汉字代表3个字节,gbk为2个字节)
	concat
	substr
	instr
	trim
	upper
	lower
	lpad
	rpad
	replace
	
	数学函数：
	round
	ceil
	floor
	truncate
	mod
	
	日期函数：
	now
	curdate
	curtime
	year
	month
	monthname
	day
	hour
	minute
	second
	str_to_date
	date_format
	其他函数：
	version
	database
	user
	控制函数
	if
	case


	

*/


#一、字符函数

#1.length 获取参数值的字节个数
	SELECT LENGTH('john');
	SELECT LENGTH('张三丰hahaha');
	SHOW VARIABLES LIKE '%char%'

#2.concat 拼接字符串

	SELECT CONCAT(last_name,'_',first_name) 姓名 FROM employees;

#3.upper、lower
	SELECT UPPER('john');
	SELECT LOWER('joHn');
#示例：将姓变大写，名变小写，然后拼接
	SELECT CONCAT(UPPER(last_name),LOWER(first_name))  姓名 FROM employees;

#4.substr、substring
	#注意：索引从1开始
	#截取从指定索引处后面所有字符
	 SELECT SUBSTR('李莫愁爱上了陆展元', 7) out_put;

#截取从指定索引处指定字符长度的字符
	SELECT SUBSTR('李莫愁爱上了陆展元',1,3) out_put;


#案例：姓名中首字符大写，其他字符小写然后用_拼接，显示出来

	SELECT CONCAT(UPPER(SUBSTR(last_name,1,1)),'_',LOWER(SUBSTR(last_name,2)))  out_put
	FROM employees;

#5.instr 返回子串第一次出现的索引，如果找不到返回0

	SELECT INSTR('杨不殷六侠悔爱上了殷六侠','殷八侠') AS out_put;

#6.trim 去掉两边的字符 

	SELECT LENGTH(TRIM('    张翠山    ')) AS out_put;

	SELECT TRIM('a' FROM 'aaaaaaaaa张aaaaaaaaaaaa翠山aaaaaaaaaaaaaaa')  AS out_put;

#7.lpad 用指定的字符实现左填充指定长度

	SELECT LPAD('殷素素',10,'*') AS out_put;

#8.rpad 用指定的字符实现右填充指定长度

	SELECT RPAD('殷素素',12,'ab') AS out_put;


#9.replace 替换

	SELECT REPLACE('周芷若周芷若周芷若周芷若张无忌爱上了周芷若','周芷若','赵敏') AS out_put;


----------------------------今天就停在这里 ----------------------------------------------


#二、数学函数

#round 四舍五入 
	SELECT ROUND(-1.55);
	SELECT ROUND(1.567,2); #小数点后保留两位 


#ceil 向上取整,返回>=该参数的最小整数

	SELECT CEIL(-1.02); 

#floor 向下取整，返回<=该参数的最大整数
	SELECT FLOOR(-9.99);

#truncate 截断

	SELECT TRUNCATE(1.69999,2);  # 小数点后保留两位 

#mod取余
/*
mod(a,b) ：  a-a/b*b

mod(-10,-3):-10- (-10)/(-3)*（-3）=-1
*/
	SELECT MOD(10,-3);
	SELECT 10%3;


#三、日期函数

#now 返回当前系统日期+时间
	SELECT NOW();

#curdate 返回当前系统日期，不包含时间
	SELECT CURDATE();

#curtime 返回当前时间，不包含日期
	SELECT CURTIME();


#可以获取指定的部分，年、月、日、小时、分钟、秒
	SELECT YEAR(NOW()) 年;
	SELECT YEAR('1998-1-1') 年;

	SELECT  YEAR(hiredate) 年 FROM employees;

	SELECT MONTH(NOW()) 月;
	SELECT MONTHNAME(NOW()) 月;


#str_to_date 将字符通过指定的格式转换成日期

	SELECT STR_TO_DATE('1998-3-2','%Y-%c-%d') AS out_put;

#查询入职日期为1992--4-3的员工信息
	SELECT * FROM employees WHERE hiredate = '1992-4-3';

	SELECT * FROM employees WHERE hiredate = STR_TO_DATE('4-3 1992','%c-%d %Y');


#date_format 将日期转换成字符

	SELECT DATE_FORMAT(NOW(),'%Y年%m月%d日') AS out_put;

#查询有奖金的员工名和入职日期(xx月/xx日 xx年)
	SELECT last_name,DATE_FORMAT(hiredate,'%m月/%d日 %y年') 入职日期
	FROM employees
	WHERE commission_pct IS NOT NULL;


#四、其他函数

	SELECT VERSION();
	SELECT DATABASE();
	SELECT USER();


#五、流程控制函数
#1.if函数： if else 的效果

	SELECT IF(10<5,'大','小');

	SELECT last_name,commission_pct,IF(commission_pct IS NULL,'没奖金，呵呵','有奖金，嘻嘻') 备注
	FROM employees;




#2.case函数的使用一： switch case 的效果

/*
java中
switch(变量或表达式){
	case 常量1：语句1;break;
	...
	default:语句n;break;


}

mysql中

case 要判断的字段或表达式
when 常量1 then 要显示的值1或语句1;
when 常量2 then 要显示的值2或语句2;
...
else 要显示的值n或语句n;
end
*/

/*案例：查询员工的工资，要求

部门号=30，显示的工资为1.1倍
部门号=40，显示的工资为1.2倍
部门号=50，显示的工资为1.3倍
其他部门，显示的工资为原工资

*/


	SELECT salary 原始工资,department_id,
	CASE department_id
	WHEN 30 THEN salary*1.1
	WHEN 40 THEN salary*1.2
	WHEN 50 THEN salary*1.3
	ELSE salary
	END AS 新工资
	FROM employees;



#3.case 函数的使用二：类似于 多重if
/*
java中：
if(条件1){
	语句1；
}else if(条件2){
	语句2；
}
...
else{
	语句n;
}

mysql中：

case 
when 条件1 then 要显示的值1或语句1
when 条件2 then 要显示的值2或语句2
。。。
else 要显示的值n或语句n
end
*/

	#案例：查询员工的工资的情况
	如果工资>20000,显示A级别
	如果工资>15000,显示B级别
	如果工资>10000，显示C级别
	否则，显示D级别


	SELECT salary,
	CASE 
	WHEN salary>20000 THEN 'A'
	WHEN salary>15000 THEN 'B'
	WHEN salary>10000 THEN 'C'
	ELSE 'D'
	END AS 工资级别
	FROM employees;




#二、分组函数
/*
功能：用作统计使用，又称为聚合函数或统计函数或组函数

分类：
sum 求和、avg 平均值、max 最大值 、min 最小值 、count 计算个数

特点：
1、sum、avg一般用于处理数值型
   max、min、count可以处理任何类型
2、以上分组函数都忽略null值

3、可以和distinct搭配实现去重的运算

4、count函数的单独介绍
一般使用count(*)用作统计行数

5、和分组函数一同查询的字段要求是group by后的字段

*/


#1、简单 的使用
	SELECT SUM(salary) FROM employees;
	SELECT AVG(salary) FROM employees;
	SELECT MIN(salary) FROM employees;
	SELECT MAX(salary) FROM employees;
	SELECT COUNT(salary) FROM employees;


	SELECT SUM(salary) 和,AVG(salary) 平均,MAX(salary) 最高,MIN(salary) 最低,COUNT(salary) 个数
FROM employees;

	SELECT SUM(salary) 和,ROUND(AVG(salary),2) 平均,MAX(salary) 最高,MIN(salary) 最低,COUNT(salary) 个数
FROM employees;

#2、参数支持哪些类型

	SELECT SUM(last_name) ,AVG(last_name) FROM employees;
	SELECT SUM(hiredate) ,AVG(hiredate) FROM employees;

	SELECT MAX(last_name),MIN(last_name) FROM employees;

	SELECT MAX(hiredate),MIN(hiredate) FROM employees;

	SELECT COUNT(commission_pct) FROM employees;
	SELECT COUNT(last_name) FROM employees;

#3、是否忽略null

	SELECT SUM(commission_pct) ,AVG(commission_pct),SUM(commission_pct)/35,SUM(commission_pct)/107 FROM employees;

	SELECT MAX(commission_pct) ,MIN(commission_pct) FROM employees;

	SELECT COUNT(commission_pct) FROM employees;
	SELECT commission_pct FROM employees;


#4、和distinct搭配

	SELECT SUM(DISTINCT salary),SUM(salary) FROM employees;

	SELECT COUNT(DISTINCT salary),COUNT(salary) FROM employees;



#5、count函数的详细介绍

	SELECT COUNT(salary) FROM employees;


	SELECT COUNT(*) FROM employees;

	SELECT COUNT(1) FROM employees;

效率：
	MYISAM存储引擎下  ，COUNT(*)的效率高
	INNODB存储引擎下，COUNT(*)和COUNT(1)的效率差不多，比COUNT(字段)要高一些


#6、和分组函数一同查询的字段有限制

	 SELECT AVG(salary),employee_id  FROM employees;

##------------------------------------------练习  ---------------
#1. 查询公司员工工资的最大值，最小值，平均值，总和

select max(salary) 最高,min(salary) 最小, avg(salary) 平均,sum(salary)
from employees
#2. 查询员工表中的最大入职时间和最小入职时间的相差天数 （DIFFRENCE）
select max(hiredate) - min(hiredate) as diffrence 
from employees

# 一个函数  datediff

select DATEDIFF(max(hiredate),min(hiredate))as diffrence
from employees
#3. 查询部门编号为 90 的员工个数

select  count(*)
from employees
where department_id = 90

#+END_SRC
* 分组查询
#+BEGIN_SRC 
#进阶5：分组查询

/*
语法：

select 查询列表
from 表
【where 筛选条件】
group by 分组的字段
【order by 排序的字段】;

特点：
1、和分组函数一同查询的字段必须是group by后出现的字段
2、筛选分为两类：分组前筛选和分组后筛选
		针对的表			位置		连接的关键字
分组前筛选	原始表				group by前	where
	
分组后筛选	group by后的结果集    		group by后	having

问题1：分组函数做筛选能不能放在where后面
答：不能
 
问题2：where——group by——having

一般来讲，能用分组前筛选的，尽量使用分组前筛选，提高效率

3、分组可以按单个字段也可以按多个字段
4、可以搭配着排序使用




*/



#引入：查询每个部门的员工个数

SELECT COUNT(*) FROM employees WHERE department_id=90;
#1.简单的分组

#案例1：查询每个工种的员工平均工资
	SELECT AVG(salary),job_id
	FROM employees
	GROUP BY job_id;

#案例2：查询每个位置的部门个数

	SELECT COUNT(*),location_id
	FROM departments
	GROUP BY location_id; 


#2、可以实现分组前的筛选

#案例1：查询邮箱中包含a字符的 每个部门的最高工资
 #随手记 :  这样想  每个后面的就是分组 然后  的后面就是 查询的东西 
		#每当有每个这样的词 那么我们就 加一个 GROUP BY 
	SELECT MAX(salary),department_id
	FROM employees
	WHERE email LIKE '%a%'
	GROUP BY department_id;


#案例2：查询有奖金的每个领导手下员工的平均工资

	SELECT AVG(salary),manager_id
	FROM employees
	WHERE commission_pct IS NOT NULL
	GROUP BY manager_id;



#3、分组后筛选

#案例：查询哪个部门的员工个数>5

#①查询每个部门的员工个数
	SELECT COUNT(*),department_id
	FROM employees
	GROUP BY department_id;

#② 筛选刚才①结果

	SELECT COUNT(*),department_id
	FROM employees

	GROUP BY department_id

	HAVING COUNT(*)>5;


#案例2：每个工种有奖金的员工的最高工资>12000的工种编号和最高工资

	SELECT job_id,MAX(salary)
	FROM employees
	WHERE commission_pct IS NOT NULL
	GROUP BY job_id
	HAVING MAX(salary)>12000;


###################案例3：领导编号>102的每个领导手下的最低工资大于5000的领导编号和最低工资

	select manager_id , min(salary)
	from employees 
	where manager_id > 102
	group by manager_id 
	having min(salary)>5000
#  先分开做   
	select manager_id , min(salary)
	from employees
	group by manager_id 
# 再加筛选条件   看条件在那个表中  如果在原始表 就是 where  如果在 group by
# 后 就   hav  ing  



#4.添加排序

#案例：每个工种有奖金的员工的最高工资>6000的工种编号和最高工资,按最高工资升序

SELECT job_id,MAX(salary) m
FROM employees
WHERE commission_pct IS NOT NULL
GROUP BY job_id
HAVING m>6000
ORDER BY m ;




#5.按多个字段分组

#案例：查询每个工 种每个部门的最低工资,并按最低工资降序

SELECT MIN(salary),job_id,department_id
FROM employees
GROUP BY department_id,job_id
ORDER BY MIN(salary) DESC;

#=============================案例
#1. 查询各 job_id 的员工工资的最大值，最小值，平均值，总和，并按 job_id 升序
	select job_id,max(salary),min(salary),sum(salary),avg(salary)
	from employees
	group by job_id
	order by job_id desc
	

#2. 查询员工最高工资和最低工资的差距（DIFFERENCE）   
		#每个员工 
	select job_id,max(salary),min(salary)
    from employees
    group by job_id 
    having DATEDIFF(max(salary),min(salary)) 
    #上面的 全错 我想复杂了 

	select max(salary)-min(salary) as 差距
    from employees
    
    
#3. 查询各个管理者手下员工的最低工资，	其中最低工资不能低于 6000， 	没有管理者的员
#工不计算在内

	select manager_id,min(salary)
    from employees
    where manager_id is not null
    group by manager_id
    having min(salary) > 6000 

#4. 查询所有部门的编号，员工数量和工资平均值,并按平均工资降序
	select department_id,count(*),avg(salary)
    from employees
    group by department_id
    order by avg(salary) desc

#5. 选择具有各个 job_id 的员工人数
	select count(*) ,job_id 
    from employees
    group by job_id


#+END_SRC
* 连接查询
#+BEGIN_SRC 
#进阶6：连接查询
/*
含义：又称多表查询，当查询的字段来自于多个表时，就会用到连接查询

笛卡尔乘积现象：表1 有m行，表2有n行，结果=m*n行

发生原因：没有有效的连接条件
如何避免：添加有效的连接条件

分类：

	按年代分类：
	sql92标准:仅仅支持内连接
	sql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接
	
	按功能分类：
		内连接：
			等值连接
			非等值连接
			自连接
		外连接：
			左外连接
			右外连接
			全外连接
		
		交叉连接


*/
	use girls

	SELECT * FROM beauty

	SELECT * FROM boys;


	SELECT NAME,boyName FROM boys,beauty
	WHERE beauty.boyfriend_id= boys.id;

#一、sql92标准
#1、等值连接
/*

① 多表等值连接的结果为多表的交集部分
②n表连接，至少需要n-1个连接条件
③ 多表的顺序没有要求
④一般需要为表起别名
⑤可以搭配前面介绍的所有子句使用，比如排序、分组、筛选


*/



#案例1：查询女神名和对应的男神名
	SELECT NAME,boyName 
	FROM boys,beauty
	WHERE beauty.boyfriend_id= boys.id;

#案例2：查询员工名和对应的部门名
	use myemployees
	SELECT last_name,department_name
	FROM employees,departments
	WHERE employees.`department_id`=departments.`department_id`;



#2、为表起别名
/*
①提高语句的简洁度
②区分多个重名的字段

注意：如果为表起了别名，则查询的字段就不能使用原来的表名去限定

*/
#查询员工名、工种号、工种名

	SELECT e.last_name,e.job_id,j.job_title
	FROM employees  e,jobs j
	WHERE e.`job_id`=j.`job_id`;


#3、两个表的顺序是否可以调换

#查询员工名、工种号、工种名

	SELECT e.last_name,e.job_id,j.job_title
	FROM jobs j,employees e
	WHERE e.`job_id`=j.`job_id`;


#4、可以加筛选


#案例：查询有奖金的员工名、部门名

	SELECT last_name,department_name,commission_pct

	FROM employees e,departments d
	WHERE e.`department_id`=d.`department_id`
	AND e.`commission_pct` IS NOT NULL;

#案例2：查询城市名中第二个字符为o的部门名和城市名

	SELECT department_name,city
	FROM departments d,locations l
	WHERE d.`location_id` = l.`location_id`
	AND city LIKE '_o%';

#5、可以加分组


#案例1：查询每个城市的部门个数

	SELECT COUNT(*) 个数,city
	FROM departments d,locations l
	WHERE d.`location_id`=l.`location_id`
	GROUP BY city;


#案例2：查询有奖金的每个部门的部门名和部门的领导编号和该部门的最低工资
	SELECT department_name,d.`manager_id`,MIN(salary)
	FROM departments d,employees e
	WHERE d.`department_id`=e.`department_id`
	AND commission_pct IS NOT NULL
	GROUP BY department_name,d.`manager_id`;
#6、可以加排序


#案例：查询每个工种的工种名和员工的个数，并且按员工个数降序

	SELECT job_title,COUNT(*)
	FROM employees e,jobs j
	WHERE e.`job_id`=j.`job_id`
	GROUP BY job_title
	ORDER BY COUNT(*) DESC;




#7、可以实现三表连接？

#案例：查询员工名、部门名和所在的城市

	SELECT last_name,department_name,city
	FROM employees e,departments d,locations l
	WHERE e.`department_id`=d.`department_id`
	AND d.`location_id`=l.`location_id`
	AND city LIKE 's%'

	ORDER BY department_name DESC;



#2、非等值连接


#案例1：查询员工的工资和工资级别


	SELECT salary,grade_level
	FROM employees e,job_grades g
	WHERE salary BETWEEN g.`lowest_sal` AND g.`highest_sal`
	AND g.`grade_level`='A';

/*
select salary,employee_id from employees;
select * from job_grades;
CREATE TABLE job_grades
(grade_level VARCHAR(3),
 lowest_sal  int,
 highest_sal int);

INSERT INTO job_grades
VALUES ('A', 1000, 2999);

INSERT INTO job_grades
VALUES ('B', 3000, 5999);

INSERT INTO job_grades
VALUES('C', 6000, 9999);

INSERT INTO job_grades
VALUES('D', 10000, 14999);

INSERT INTO job_grades
VALUES('E', 15000, 24999);

INSERT INTO job_grades
VALUES('F', 25000, 40000);

*/




#3、自连接

#同一张表找两次 

#案例：查询 员工名和上级的名称
 
	SELECT e.employee_id,e.last_name,m.employee_id,m.last_name
	FROM employees e,employees m
	WHERE e.`manager_id`=m.`employee_id`;
    
    
    
    
    
   ################################################## 
    #显示员工表的最大工资,平均工资

	select max(salary),avg(salary)
	from employees

#查询员工表的employee_id, job_id , last_name 按照 department_id 降序
#salary 升序 
	select e.employee_id,e.job_id,e.last_name,d.department_id,e.salary
	from employees e,departments d
	order by d.department_id desc,salary asc


#查询员工表的 job_id中包含a 和 e 的,并且 a在e 的前面

	select job_id 
	from employees 
	where job_id like "%a%e%"

# 已知 表 student 里面有 id (学号) ,name ,gradeID (年纪号)
	#已知表 grade 里面有  id (年级编号) name (年级名字)
    #已知表 result 里面有 id,scoure,studentNO(学号)
    #要求查  姓名.年级名  成绩 

	select s.name ,g.name ,r.scoure
    from student s , grade g,result r
    where g.id = s.gradeID
    and s.id = r.studentNO
    
#显示当前日期  ,以及去前后空格,截取子字符串的函数 

	select now()
	select trim()
	select substr()








-----------------------------------
#1. 显示所有员工的姓名，部门号和部门名称。
	select e.last_name ,d.department_id,d.department_name
    from departments d,employees e
    where e.department_id = d.department_id
#2. 查询 90 号部门员工的 job_id 和 90 号部门的 location_id
	select job_id ,location_id ,d.department_id
    from departments d , employees e 
    where e.department_id = d.department_id
    and d.department_id = 90
#3. 选择所有有奖金的员工的
#last_name , department_name , location_id , city
	select e.last_name,d.department_name,l.location_id,l.city ,e.commission_pct
    from employees e,departments d,locations l
    where l.location_id = d.location_id
    and d.department_id = e.department_id 
    and commission_pct is not null
    


#4. 选择city在Toronto工作的员工的
#last_name , job_id , department_id , department_name
	 select e.last_name,e.job_id,d.department_id,d.department_name,l.city
	 from employees e,departments d ,locations l
	 where d.department_id = e.department_id
	 and d.location_id = l.location_id
	 and city = 'Toronto'
#5.查询每个工种、每个部门的部门名、工种名和最低工资
	select d.department_id,j.job_id,min(salary)
    from employees e,departments d ,jobs j
	 where d.department_id = e.department_id
	 and e.job_id = j.job_id
     group by j.job_id,d.department_id
#6.查询每个国家下的部门个数大于 2 的国家编号
select l.country_id ,count(*) as 部门个数
    from locations l,departments d
    where d.location_id = l.location_id
    group by l.country_id
    having 部门个数>2

#+END_SRC
* 连接查询99语法
#+BEGIN_SRC 
#二、sql99语法
/*
语法：
	select 查询列表
	from 表1 别名 【连接类型】
	join 表2 别名 
	on 连接条件
	【where 筛选条件】
	【group by 分组】
	【having 筛选条件】
	【order by 排序列表】
	

分类：
内连接（★）：inner
外连接
	左外(★):left 【outer】
	右外(★)：right 【outer】
	全外：full【outer】
交叉连接：cross 

*/


#一）内连接
/*
语法：

select 查询列表
from 表1 别名
inner join 表2 别名
on 连接条件;

分类：
等值
非等值
自连接

特点：
①添加排序、分组、筛选
②inner可以省略
③ 筛选条件放在where后面，连接条件放在on后面，提高分离性，便于阅读
④inner join连接和sql92语法中的等值连接效果是一样的，都是查询多表的交集





*/


#1、等值连接
#案例1.查询员工名、部门名

	SELECT last_name,department_name
	FROM departments d
	 JOIN  employees e
	ON e.`department_id` = d.`department_id`;



#案例2.查询名字中包含e的员工名和工种名（添加筛选）
	SELECT last_name,job_title
	FROM employees e
	INNER JOIN jobs j
	ON e.`job_id`=  j.`job_id`
	WHERE e.`last_name` LIKE '%e%';



#3. 查询部门个数>3的城市名和部门个数，（添加分组+筛选）

#①查询每个城市的部门个数
#②在①结果上筛选满足条件的
	SELECT city,COUNT(*) 部门个数
	FROM departments d
	INNER JOIN locations l
	ON d.`location_id`=l.`location_id`
	GROUP BY city
	HAVING COUNT(*)>3;




#案例4.查询哪个部门的员工个数>3的部门名和员工个数，并按个数降序（添加排序）

#①查询每个部门的员工个数
	SELECT COUNT(*),department_name
	FROM employees e
	INNER JOIN departments d
	ON e.`department_id`=d.`department_id`
	GROUP BY department_name

#② 在①结果上筛选员工个数>3的记录，并排序

	SELECT COUNT(*) 个数,department_name
	FROM employees e
	INNER JOIN departments d
	ON e.`department_id`=d.`department_id`
	GROUP BY department_name
	HAVING COUNT(*)>3
	ORDER BY COUNT(*) DESC;

#5.查询员工名、部门名、工种名，并按部门名降序（添加三表连接）

	SELECT last_name,department_name,job_title
	FROM employees e
	INNER JOIN departments d ON e.`department_id`=d.`department_id`
	INNER JOIN jobs j ON e.`job_id` = j.`job_id`

	ORDER BY department_name DESC;

#二）非等值连接

#查询员工的工资级别

	SELECT salary,grade_level
	FROM employees e
	 JOIN job_grades g
	 ON e.`salary` BETWEEN g.`lowest_sal` AND g.`highest_sal`;
 
 
 #查询工资级别的个数>20的个数，并且按工资级别降序
	 SELECT COUNT(*),grade_level
	FROM employees e
	 JOIN job_grades g
	 ON e.`salary` BETWEEN g.`lowest_sal` AND g.`highest_sal`
	 GROUP BY grade_level
	 HAVING COUNT(*)>20
	 ORDER BY grade_level DESC;
 
 ##########一般  个数 都是 count(*) 把所有的都列出来 然后 group by  分组  ok
 
 
 #三）自连接
 
 #查询员工的名字、上级的名字
	 SELECT e.last_name,m.last_name
	 FROM employees e
	 JOIN employees m
	 ON e.`manager_id`= m.`employee_id`;
 
  #查询姓名中包含字符k的员工的名字、上级的名字
	 SELECT e.last_name,m.last_name
	 FROM employees e
	 JOIN employees m
	 ON e.`manager_id`= m.`employee_id`
	 WHERE e.`last_name` LIKE '%k%';
	 
 
 #二、外连接
 
 /*
 应用场景：用于查询一个表中有，另一个表没有的记录
 
 特点：
 1、外连接的查询结果为主表中的所有记录
	如果从表中有和它匹配的，则显示匹配的值
	如果从表中没有和它匹配的，则显示null
	外连接查询结果=内连接结果+主表中有而从表没有的记录
 2、左外连接，left join左边的是主表
    右外连接，right join右边的是主表
 3、左外和右外交换两个表的顺序，可以实现同样的效果 
 4、全外连接=内连接的结果+表1中有但表2没有的+表2中有但表1没有的
 */
 #引入：查询男朋友 不在男神表的的女神名
 
	 SELECT * FROM beauty;
	 SELECT * FROM boys;
	 use girls
 #左外连接
 
	 SELECT b.name,bo.*
	 FROM boys bo
	 LEFT OUTER JOIN beauty b
	 ON b.`boyfriend_id` = bo.`id`
	 WHERE b.`id` IS NULL;
 
 
 #案例1：查询哪个部门没有员工
 #左外
	 SELECT d.*,e.employee_id
	 FROM departments d
	 LEFT OUTER JOIN employees e
	 ON d.`department_id` = e.`department_id`
	 WHERE e.`employee_id` IS NULL;
 
 
 #右外
 
	  SELECT d.*,e.employee_id
	 FROM employees e
	 RIGHT OUTER JOIN departments d
	 ON d.`department_id` = e.`department_id`
	 WHERE e.`employee_id` IS NULL;
 
 
 #全外
 
 
	 USE girls;
	 SELECT b.*,bo.*
	 FROM beauty b
	 FULL OUTER JOIN boys bo
	 ON b.`boyfriend_id` = bo.id;
 

 #交叉连接   交叉连接  全部乘一遍 
 
	 SELECT b.*,bo.*
	 FROM beauty b
	 CROSS JOIN boys bo;
 
 
 
 #sql92和 sql99pk
 /*
 功能：sql99支持的较多
 可读性：sql99实现连接条件和筛选条件的分离，可读性较高
 */ 







-----------------------------------------------------
#一、查询编号>3 的女神 的  男朋友信息，如果有则列出详细，如果没有，用 null 填充
use girls
	select  bo.* , b.name,b.id
    from boys bo
    left outer join beauty b
    on bo.id = b.boyfriend_id
    where b.id >3
    
    做错了   改正版     女神是主表  有的女神不一定有男朋友  
    select  bo.* , b.name,b.id
	from beauty b
	left outer join boys bo
	on bo.id = b.boyfriend_id
	where b.id >3

#二、查询哪个城市没有部门
	use myemployees
	
    select city, d.department_name 
    from locations l
    left outer join departments d
    on d.location_id = l.location_id
    where d.department_name is null
    

城市是主表 有的城市 没有部门  不一定有部门 

#三、查询部门名为 SAL 或 IT 的员工信息
	select e.* ,department_name 
    from departments d
    left outer join employees e
    on d.department_id = e.department_id
    where department_name in ("SAL",'IT')

	错了  这样想 部门是肯定有的  
#+END_SRC
* 子查询
#+BEGIN_SRC 
#进阶7：子查询
/*
含义：
出现在其他语句中的select语句，称为子查询或内查询
外部的查询语句，称为主查询或外查询

分类：
按子查询出现的位置：
	select后面：
		仅仅支持标量子查询
	
	from后面：
		支持表子查询
	where或having后面：★
		标量子查询（单行） √  查询出的东西是  一行 一列 就是一个数据
		列子查询  （多行） √
		
		行子查询
		
	exists后面（相关子查询）
		表子查询
按结果集的行列数不同：
	标量子查询（结果集只有一行一列）
	列子查询（结果集只有一列多行）
	行子查询（结果集有一行多列）
	表子查询（结果集一般为多行多列）



*/


#一、where或having后面
/*
1、标量子查询（单行子查询）
2、列子查询（多行子查询）

3、行子查询（多列多行）

特点：
①子查询放在小括号内
②子查询一般放在条件的右侧
③标量子查询，一般搭配着单行操作符使用
> < >= <= = <>

列子查询，一般搭配着多行操作符使用
in、any/some、all

④子查询的执行优先于主查询执行，主查询的条件用到了子查询的结果

*/
#1.标量子查询★

#案例1：谁的工资比 Abel 高?

	#①查询Abel的工资
	SELECT salary
	FROM employees
	WHERE last_name = 'Abel'# 是一行一列 就用 标量子查询

#②查询员工的信息，满足 salary>①结果
	SELECT *
	FROM employees
	WHERE salary>(

		SELECT salary
		FROM employees
		WHERE last_name = 'Abel'

	);

#案例2：返回job_id与 141号员工相同，salary比143号员工多的员工 姓名，job_id 和工资

#①查询141号员工的job_id
	SELECT job_id
	FROM employees
	WHERE employee_id = 141

#②查询143号员工的salary
	SELECT salary
	FROM employees
	WHERE employee_id = 143

#③查询员工的姓名，job_id 和工资，要求job_id=①并且salary>②

	SELECT last_name,job_id,salary
	FROM employees
	WHERE job_id = (
		SELECT job_id
		FROM employees
		WHERE employee_id = 141
	) AND salary>(
		SELECT salary
		FROM employees
		WHERE employee_id = 143

	);


#案例3：返回公司工资最少的员工的last_name,job_id和salary

#①查询公司的 最低工资
	SELECT MIN(salary)
	FROM employees

#②查询last_name,job_id和salary，要求salary=①
	SELECT last_name,job_id,salary
	FROM employees
	WHERE salary=(
		SELECT MIN(salary)
		FROM employees
	);


#案例4：查询最低工资大于50号部门最低工资的部门id和其最低工资

#①查询50号部门的最低工资
	SELECT  MIN(salary)
	FROM employees
	WHERE department_id = 50

#②查询每个部门的最低工资

	SELECT MIN(salary),department_id
	FROM employees
	GROUP BY department_id

#③ 在②基础上筛选，满足min(salary)>①
	SELECT MIN(salary),department_id
	FROM employees
	GROUP BY department_id
	HAVING MIN(salary)>(
		SELECT  MIN(salary)
		FROM employees
		WHERE department_id = 50


);

#非法使用标量子查询

	SELECT MIN(salary),department_id
	FROM employees
	GROUP BY department_id
	HAVING MIN(salary)>(
		SELECT  salary
		FROM employees
		WHERE department_id = 250


	);



#2.列子查询（多行子查询）★
#案例1：返回location_id是1400或1700的部门中的所有员工姓名

#①查询location_id是1400或1700的部门编号
	SELECT DISTINCT department_id
	FROM departments
	WHERE location_id IN(1400,1700)

#②查询员工姓名，要求部门号是①列表中的某一个

	 SELECT last_name
	FROM employees
	WHERE department_id  1 (
		SELECT DISTINCT department_id
		FROM departments
		WHERE location_id IN(1400,1700)
	);


#案例2：返回其它工种中比job_id为‘IT_PROG’工种任一工资低的员工的员工号、姓名、job_id 以及salary

#①查询job_id为‘IT_PROG’部门任一工资

	SELECT DISTINCT salary
	FROM employees
	WHERE job_id = 'IT_PROG'

#②查询员工号、姓名、job_id 以及salary，salary<(①)的任意一个
	SELECT last_name,employee_id,job_id,salary
	FROM employees
	WHERE salary<ANY(
		SELECT DISTINCT salary
		FROM employees
		WHERE job_id = 'IT_PROG'

	) AND job_id<>'IT_PROG';

#或
	SELECT last_name,employee_id,job_id,salary
	FROM employees
	WHERE salary<(
		SELECT MAX(salary)
		FROM employees
		WHERE job_id = 'IT_PROG'

	) AND job_id<>'IT_PROG';

------------------------------- 89    16
#案例3：返回其它部门中比job_id为‘IT_PROG’部门所有工资都低的员工   的员工号、姓名、job_id 以及salary

	SELECT last_name,employee_id,job_id,salary
	FROM employees
	WHERE salary<ALL(
		SELECT DISTINCT salary
		FROM employees
		WHERE job_id = 'IT_PROG'

	) AND job_id<>'IT_PROG';

#或

	SELECT last_name,employee_id,job_id,salary
	FROM employees
	WHERE salary<(
		SELECT MIN( salary)
		FROM employees
		WHERE job_id = 'IT_PROG'

	) AND job_id<>'IT_PROG';



#3、行子查询（结果集一行多列或多行多列）

#案例：查询员工编号最小并且工资最高的员工信息



	SELECT * 
	FROM employees
	WHERE (employee_id,salary)=(
		SELECT MIN(employee_id),MAX(salary)
		FROM employees
	);

#①查询最小的员工编号
	SELECT MIN(employee_id)
	FROM employees


#②查询最高工资
	SELECT MAX(salary)
	FROM employees


#③查询员工信息
	SELECT *
	FROM employees
	WHERE employee_id=(
		SELECT MIN(employee_id)
		FROM employees


	)AND salary=(
		SELECT MAX(salary)
		FROM employees

	);


#二、select后面
/*
仅仅支持标量子查询
*/

#案例：查询每个部门的员工个数


	SELECT d.*,(

		SELECT COUNT(*)
		FROM employees e 
		WHERE e.department_id = d.`department_id`
	 ) 个数
	 FROM departments d;
	 
	 
 #案例2：查询员工号=102的部门名
	select department_name , employee_id 
	from departments d 
	inner join employees e
	on d.department_id = e.department_id
	where e.employee_id= 102



#这个就没必要    出来的成绩是  两行两列 然后select 后面跟的 只支持一行一列的


	SELECT (
		SELECT department_name,e.department_id
		FROM departments d
		INNER JOIN employees e
		ON d.department_id=e.department_id
		WHERE e.employee_id=102
		
	) 部门名;



#三、from后面
/*
将子查询结果充当一张表，要求必须起别名
*/

#案例：查询每个部门的 平均工资 的  工资等级
#①查询每个部门的平均工资
	SELECT AVG(salary),department_id
	FROM employees
	GROUP BY department_id


	SELECT * FROM job_grades;


#②连接①的结果集和job_grades表，筛选条件平均工资 between lowest_sal and highest_sal

	SELECT  ag_dep.*,g.`grade_level`
	FROM (
		SELECT AVG(salary) ag,department_id
		FROM employees
		GROUP BY department_id
	) ag_dep
	INNER JOIN job_grades g
	ON ag_dep.ag BETWEEN lowest_sal AND highest_sal;



#四、exists后面（相关子查询）

/*
语法：
exists(完整的查询语句)
结果：
1或0



*/

	SELECT EXISTS(SELECT employee_id FROM employees WHERE salary=12000);

#案例1：查询有员工的部门名

#in

	select department_name 
	from departments d
	where department_id is not null



	SELECT department_name
	FROM departments d
	WHERE d.`department_id` IN(
		SELECT department_id
		FROM employees

	)

	按照本意 我写的  是第一个  答案是第二个  我发现好像两个  department_id 不同 我们去查一下 
	select DISTINCT department_id 
	from departments    27rows

	select DISTINCT department_id 
	from employees 		107 rows 

	所以我错了  因该是  

	select department_name
	from departments d
	where d.department_id in (
				select department_id 
				from employees
	)



#案例1：查询有员工的部门名

#exists

	SELECT department_name
	FROM departments d
	WHERE EXISTS(
		SELECT *
		FROM employees e
		WHERE d.`department_id`=e.`department_id`
	);


#案例2：查询没有女朋友的男神信息

#in
	use girls
	SELECT bo.*
	FROM boys bo
	WHERE bo.id NOT IN(
		SELECT boyfriend_id
		FROM beauty
	)

	select bo.*
	from boys bo 
	where exists (
		select boyfriend_id 
		from beauty b
		where bo.`id`=b.`boyfriend_id`
	)


#exists
	SELECT bo.*
	FROM boys bo
	WHERE NOT EXISTS(
		SELECT boyfriend_id
		FROM beauty b
		WHERE bo.`id`=b.`boyfriend_id`

	); 












-------------------------------课后题 
#1. 查询和 Zlotkey 相同部门的员工姓名和工资

	use myemployees

	select last_name
	from employees
		#(1) 先查询zlotkey 的部门 
	    select d.department_name
	    from departments d
		join employees e
	    on e.department_id = d.department_id
	    where e.last_name = 'Zlotkey'
    #(2) 再查询这个部门 每个员工的 姓名和 工资
    
	    
		select last_name , salary 
	    	from employees
		where department_id = (
			SELECT department_id
			FROM employees
			WHERE last_name = 'Zlotkey'
	   	 )
    
    94
    #(3) 再  筛选 
	

#1. 查询和 Zlotkey 相同部门的员工姓名和工资

	select department_id 
	    from employees
	    where last_name = "Zlotkey"
	    
	    select last_name , salary 
	    from employees 
	    where department_id = (
			select department_id 
			from employees
			where last_name = "Zlotkey"
    		)








#2. 查询工资比公司平均工资高的员工的员工号，姓名和工资。

	select avg(salary)
        from employees
        
        select job_id,last_name,salary
        from employees
        where salary > (
				select avg(salary)
				from employees
        )
       
       ---标准答案 
    	SELECT last_name,employee_id,salary
	FROM employees
	WHERE salary>(

		SELECT AVG(salary)
		FROM employees
	);    
        
        
        
        
        



#3. 查询各部门中工资比本部门平均工资高  的员工的员工号, 姓名和工资   (做错了  )  
	select avg(salary)
    from employees
    group by department_id
	


	select job_id,last_name,salary,department_id
	    from employees 
	    where salary > any(
				select avg(salary)
				from employees
				group by department_id
	   		 )



	SELECT employee_id,last_name,salary,e.department_id
	FROM employees e
	INNER JOIN (
		SELECT AVG(salary) ag,department_id
		FROM employees
		GROUP BY department_id
		) ag_dep
		ON e.department_id = ag_dep.department_id
		WHERE salary>ag_dep.ag ;


#4. 查询姓名中包含字母 u 的员工 在相同部门 的 员工的员工号和姓名
	select department_id
    from employees 
    where last_name like "%u%"
    
    
    select job_id,last_name
    from employees
    where department_id = any(
			select department_id
			from employees 
			where last_name like "%u%"
    )
    


    SELECT last_name,employee_id
	FROM employees
	WHERE department_id IN(
		SELECT  DISTINCT department_id
		FROM employees
		WHERE last_name LIKE '%u%'
	);


#5. 查询在部门的 location_id 为 1700 的 部门工作 的员工   的员工号
	select distinct department_id
    from departments
    where location_id = 1700


	select employee_id 
    from employees 
    where department_id = any(
			select distinct department_id
			from departments
			where location_id = 1700
		
    )














#6. 查询管理者是 King 的员工姓名和工资
	select employee_id 
    from employees
    where last_name = 'K_ing'
	
	select last_name,salary
    from employees
    where manager_id = any(
			select employee_id 
			from employees
			where last_name = 'K_ing'
    )



#7. 查询工资最高的员工的姓名，要求 first_name 和 last_name 显示为一列，列名为 姓.名

	select max(salary)
    from employees


select concat(last_name,first_name) "姓.名"
from employees
where salary in (
	select max(salary)
    from employees
)

SELECT CONCAT(first_name,last_name) "姓.名"
FROM employees
WHERE salary=(
	SELECT MAX(salary)
	FROM employees

);
#+END_SRC
* 子查询例题
#+BEGIN_SRC 
# 1. 查询工资最低的员工信息: last_name, salary

#①查询最低的工资
select min(salary) 
from employees
#②查询last_name,salary，要求salary=①
select last_name ,salary 
from employees
where salary = (
	select min(salary) 
	from employees
)




# 2. 查询平均工资最低的部门信息

#方式一：
#①各部门的平均工资
	select avg(salary),department_id
    from employees
    group by department_id
#②查询①结果上的最低平均工资
	
	select min(ag)
    from (
		select avg(salary)
		from employees
		group by department_id
    )ag_dep
 

#③查询哪个部门的平均工资=②
	select avg(salary),department_id
    from employees
    group by department_id 
    having avg(salary) = (
					select min(ag)
				from (
					select avg(salary)
					from employees
					group by department_id
				)ag_dep
    );


#④查询部门信息
	select d.*
    from departments d
    where d.department_id = (
    	select avg(salary),department_id
		from employees
		group by department_id 
		having avg(salary) = (
						select min(ag)
						from (
						select avg(salary)
						from employees
						group by department_id
								)ag_dep
						)

    )

# 2. 查询平均工资最低的部门信息

#方式二：
#①各部门的平均工资
	select department_id ,avg(salary)
    from employees
    group by department_id

#②求出最低平均工资的部门编号
	select department_id
    from employees
    group by department_id
    order by avg(salary)
    limit 1



#③查询部门信息
	select *
    from departments
    where department_id = (
		select department_id
		from employees
		group by department_id
		order by avg(salary)
		limit 1
    )
-----------------------------
SELECT *
FROM departments
WHERE department_id=(
	SELECT department_id
	FROM employees
	GROUP BY department_id
	ORDER BY AVG(salary) 
	LIMIT 1
);




# 3. 查询平均工资最低的部门信息 和  该部门的平均工资
#①各部门的平均工资
	select avg(salary)
    from employees
    group by department_id
	


#②求出最低平均工资的部门编号
	select department_id 
    from employees 
    group by department_id
    order by avg(salary)
    limit 1 


#③查询部门信息
	select d.* ,ag
    from departments d
	join (
		select department_id ,avg(salary) ag
		from employees 
		group by department_id
		order by ag
		limit 1
    )ag_dep 
    on d.department_id = ag_dep.department_id

# 4. 查询平均工资最高的 job 信息
#①查询最高的job的平均工资
	select avg(salary),job_id
    from employees
    group by job_id
    order by avg(salary) desc
	limit 1

#②查询job信息
	select *
    from jobs
    where job_id = (
		select job_id
		from employees
		group by job_id
		order by avg(salary) desc
		limit 1
			
    ) 




# 5. 查询平均工资 高于 公司平均工资的部门有哪些?

#①查询平均工资
	select avg(salary)
    from employees
#②查询每个部门的平均工资
	select avg(salary)
    from employees
    group by department_id
#③筛选②结果集，满足平均工资>①
	SELECT AVG(salary),department_id
    from employees 
    group by department_id
    having avg(salary) > (
		select avg(salary)
        from employees
    )




# 6. 查询出公司中所有 manager 的详细信息.
#①查询所有manager的员工编号
	select distinct manager_id
    from employees

#②查询详细信息，满足employee_id=①
	select *
    from employees
    where employee_id = any(
		select distinct manager_id
		from employees
    )



# 7. 各个部门中 最高工资中最低的那个部门的 最低工资是多少

#①查询各部门的最高工资中最低的部门编号
	select department_id
    from employees
    group by department_id
    order by max(salary) 
    limit 1

#②查询①结果的那个部门的最低工资
	select min(salary)
    from employees
    where department_id = (
			select department_id
			from employees
			group by department_id
			order by max(salary) 
			limit 1
    )



# 8. 查询平均工资最高 的 部门的 manager 的详细信息
#: last_name, department_id, email, salary
	
#①查询平均工资最高的部门编号
	SELECT 
		department_id 
	FROM
		employees 
	GROUP BY department_id 
	ORDER BY AVG(salary) DESC 
	LIMIT 1 

#②将employees和departments连接查询，筛选条件是①
	
    SELECT 
        last_name, d.department_id, email, salary 
    FROM
        employees e 
        inner join departments d 
        ON d.manager_id = e.employee_id 
	WHERE d.department_id = 
			(SELECT 
				department_id 
			FROM
				employees 
			GROUP BY department_id 
			ORDER BY AVG(salary) DESC 
			LIMIT 1) ;  

#+END_SRC
* 分页查询
#+BEGIN_SRC 
#进阶8：分页查询 ★
/*

应用场景：当要显示的数据，一页显示不全，需要分页提交sql请求
语法：
	select 查询列表
	from 表
	【join type join 表2
	on 连接条件
	where 筛选条件
	group by 分组字段
	having 分组后的筛选
	order by 排序的字段】
	limit 【offset,】size;
	
	offset要显示条目的起始索引（起始索引从0开始）
	size 要显示的条目个数
特点：
	①limit语句放在查询语句的最后
	②公式
	要显示的页数 page，每页的条目数size
	
	select 查询列表
	from 表
	limit (page-1)*size,size;
	
	size=10
	page  
	1	0
	2  	10
	3	20
	
*/
#案例1：查询前五条员工信息


	SELECT * FROM  employees LIMIT 0,5;
	SELECT * FROM  employees LIMIT 5;


#案例2：查询第11条——第25条
	SELECT * FROM  employees LIMIT 10,15;


#案例3：有奖金的员工信息，并且工资较高的前10名显示出来
	SELECT 
		* 
	FROM
		employees 
	WHERE commission_pct IS NOT NULL 
	ORDER BY salary DESC 
	LIMIT 10 ;

#+END_SRC
* 联合查询
#+BEGIN_SRC 
#进阶9：联合查询
/*
union 联合 合并：将多条查询语句的结果合并成一个结果

语法：
查询语句1
union
查询语句2
union
...


应用场景：
要查询的结果来自于多个表，且多个表没有直接的连接关系，但查询的信息一致时

特点：★
1、要求多条查询语句的查询列数是一致的！
2、要求多条查询语句的查询的每一列的类型和顺序最好一致
3、union关键字默认去重，如果使用union all 可以包含重复项

*/


#引入的案例：查询部门编号>90或邮箱包含a的员工信息

SELECT * FROM employees WHERE email LIKE '%a%' OR department_id>90;;

SELECT * FROM employees  WHERE email LIKE '%a%'
UNION
SELECT * FROM employees  WHERE department_id>90;


#案例：查询中国用户中男性的信息 以及 外国用户中年男性的用户信息

SELECT id,cname FROM t_ca WHERE csex='男'
UNION ALL
SELECT t_id,tname FROM t_ua WHERE tGender='male';


#+END_SRC
* 插入修改删除
#+BEGIN_SRC 
#DML语言
/*
数据操作语言：
插入：insert
修改：update
删除：delete

*/

#一、插入语句
#方式一：经典的插入
/*
语法：
insert into 表名(列名,...) values(值1,...);

*/
SELECT * FROM beauty;
#1.插入的值的类型要与列的类型一致或兼容
INSERT INTO beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)
VALUES(13,'唐艺昕','女','1990-4-23','1898888888',NULL,2);

#2.不可以为null的列必须插入值。可以为null的列如何插入值？
#方式一：
INSERT INTO beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)
VALUES(13,'唐艺昕','女','1990-4-23','1898888888',NULL,2);

#方式二：

INSERT INTO beauty(id,NAME,sex,phone)
VALUES(15,'娜扎','女','1388888888');


#3.列的顺序是否可以调换
INSERT INTO beauty(NAME,sex,id,phone)
VALUES('蒋欣','女',16,'110');


#4.列数和值的个数必须一致

INSERT INTO beauty(NAME,sex,id,phone)
VALUES('关晓彤','女',17,'110');

#5.可以省略列名，默认所有列，而且列的顺序和表中列的顺序一致

INSERT INTO beauty
VALUES(18,'张飞','男',NULL,'119',NULL,NULL);

#方式二：
/*

语法：
insert into 表名
set 列名=值,列名=值,...
*/


INSERT INTO beauty
SET id=19,NAME='刘涛',phone='999';


#两种方式大pk ★


#1、方式一支持插入多行,方式二不支持

INSERT INTO beauty
VALUES(23,'唐艺昕1','女','1990-4-23','1898888888',NULL,2)
,(24,'唐艺昕2','女','1990-4-23','1898888888',NULL,2)
,(25,'唐艺昕3','女','1990-4-23','1898888888',NULL,2);

#2、方式一支持子查询，方式二不支持

INSERT INTO beauty(id,NAME,phone)
SELECT 26,'宋茜','11809866';

INSERT INTO beauty(id,NAME,phone)
SELECT id,boyname,'1234567'
FROM boys WHERE id<3;

#二、修改语句

/*

1.修改单表的记录★

语法：
update 表名
set 列=新值,列=新值,...
where 筛选条件;

2.修改多表的记录【补充】

语法：
sql92语法：
update 表1 别名,表2 别名
set 列=值,...
where 连接条件
and 筛选条件;

sql99语法：
update 表1 别名
inner|left|right join 表2 别名
on 连接条件
set 列=值,...
where 筛选条件;


*/


#1.修改单表的记录
#案例1：修改beauty表中姓唐的女神的电话为13899888899

UPDATE beauty SET phone = '13899888899'
WHERE NAME LIKE '唐%';

#案例2：修改boys表中id好为2的名称为张飞，魅力值 10
UPDATE boys SET boyname='张飞',usercp=10
WHERE id=2;



#2.修改多表的记录

#案例 1：修改张无忌的女朋友的手机号为114

UPDATE boys bo
INNER JOIN beauty b ON bo.`id`=b.`boyfriend_id`
SET b.`phone`='119',bo.`userCP`=1000
WHERE bo.`boyName`='张无忌';



#案例2：修改没有男朋友的女神的男朋友编号都为2号

UPDATE boys bo
RIGHT JOIN beauty b ON bo.`id`=b.`boyfriend_id`
SET b.`boyfriend_id`=2
WHERE bo.`id` IS NULL;

SELECT * FROM boys;


#三、删除语句
/*

方式一：delete
语法：

1、单表的删除【★】
delete from 表名 where 筛选条件

2、多表的删除【补充】

sql92语法：
delete 表1的别名,表2的别名
from 表1 别名,表2 别名
where 连接条件
and 筛选条件;

sql99语法：

delete 表1的别名,表2的别名
from 表1 别名
inner|left|right join 表2 别名 on 连接条件
where 筛选条件;



方式二：truncate
语法：truncate table 表名;

*/

#方式一：delete
#1.单表的删除
#案例：删除手机号以9结尾的女神信息

DELETE FROM beauty WHERE phone LIKE '%9';
SELECT * FROM beauty;


#2.多表的删除

#案例：删除张无忌的女朋友的信息

DELETE b
FROM beauty b
INNER JOIN boys bo ON b.`boyfriend_id` = bo.`id`
WHERE bo.`boyName`='张无忌';


#案例：删除黄晓明的信息以及他女朋友的信息
DELETE b,bo
FROM beauty b
INNER JOIN boys bo ON b.`boyfriend_id`=bo.`id`
WHERE bo.`boyName`='黄晓明';



#方式二：truncate语句

#案例：将魅力值>100的男神信息删除
TRUNCATE TABLE boy3s ;



#delete pk truncate【面试题★】

/*

1.delete 可以加where 条件，truncate不能加

2.truncate删除，效率高一丢丢
3.假如要删除的表中有自增长列，
如果用delete删除后，再插入数据，自增长列的值从断点开始，
而truncate删除后，再插入数据，自增长列的值从1开始。
4.truncate删除没有返回值，delete删除有返回值

5.truncate删除不能回滚，delete删除可以回滚.

*/

SELECT * FROM boys;

DELETE FROM boys;
TRUNCATE TABLE boys;
INSERT INTO boys (boyname,usercp)
VALUES('张飞',100),('刘备',100),('关云长',100);




作业  -------------------


试
#1. 运行以下脚本创建表 my_employees
use myemployees

Create table my_employees(
Id int(10),
First_name varchar(10),
Last_name varchar(10),
Userid varchar(10),
Salary double(10,2)
)
desc my_employees
create table users(
id int,
userid varchar(10),
department_id int
)
#2. 显示表 my_employees 的结构
#3. 向 my_employees 表中插入下列数据
use myemployees
INSERT INTO my_employees
VALUES(1,'patel','Ralph','Rpatel',895),
(2,'Dancs','Betty','Bdancs',860),
(3,'Biri','Ben','Bbiri',1100),
(4,'Newman','Chad','Cnewman',750),
(5,'Ropeburn','Audrey','Aropebur',1550);

select * from my_employees

TRUNCATE TABLE my_employees;


#方式二：

INSERT INTO my_employees
SELECT 1,'patel','Ralph','Rpatel',895 UNION
SELECT 2,'Dancs','Betty','Bdancs',860 UNION
SELECT 3,'Biri','Ben','Bbiri',1100 UNION
SELECT 4,'Newman','Chad','Cnewman',750 UNION
SELECT 5,'Ropeburn','Audrey','Aropebur',1550;
ID FIRST_NAME LAST_NAME USERID SALARY
		#1 patel Ralph Rpatel 895
		#2 Dancs Betty Bdancs 860
		#3 Biri Ben Bbiri 1100
		#4 Newman Chad Cnewman 750
		#5 Ropeburn Audrey Aropebur 1550
#4. 向 users 表中插入数据
		1 Rpatel 10
		2 Bdancs 10
		3 Bbiri 20
		4 Cnewman 30
		5 Aropebur 40


INSERT INTO users
VALUES(1,'Rpatel',10),
(2,'Bdancs',10),
(3,'Bbiri',20);

#5. 将 3 号员工的 last_name 修改为“drelxer”
UPDATE my_employees SET last_name='drelxer' WHERE id = 3;

#6. 将所有工资少于 900 的员工的工资修改为 1000
UPDATE my_employees SET salary=1000 WHERE salary<900;

#7. 将 userid 为 Bbiri 的 user 表和 my_employees 表的记录全部删除
DELETE u,e
FROM users u
JOIN my_employees e ON u.`userid`=e.`Userid`
WHERE u.`userid`='Bbiri';

#8. 删除所有数据
	DELETE FROM my_employees;
	DELETE FROM users;


#9. 检查所作的修正

SELECT * FROM my_employees;
SELECT * FROM users;


#10. 清空表 my_employees
TRUNCATE TABLE my_employees;

#+END_SRC
* 库和表的使用
#+BEGIN_SRC 
/*

数据定义语言

库和表的管理

一、库的管理
创建、修改、删除
二、表的管理
创建、修改、删除

创建： create
修改： alter
删除： drop

*/

#一、库的管理
#1、库的创建
/*
语法：
create database  [if not exists]库名;
*/ 


#案例：创建库Books

	CREATE DATABASE IF NOT EXISTS books ;


#2、库的修改

	RENAME DATABASE books TO 新库名;

#更改库的字符集

	ALTER DATABASE books CHARACTER SET utf8;


#3、库的删除

	DROP DATABASE IF EXISTS books;




#二、表的管理
#1.表的创建 ★

/*
语法：
create table 表名(
	列名 列的类型【(长度) 约束】,
	列名 列的类型【(长度) 约束】,
	列名 列的类型【(长度) 约束】,
	...
	列名 列的类型【(长度) 约束】


)


*/
#案例：创建表Book
	use books
	CREATE TABLE book(
		id INT,#编号
		bName VARCHAR(20),#图书名
		price DOUBLE,#价格
		authorId  INT,#作者编号
		publishDate DATETIME#出版日期
	);


	DESC book;

#案例：创建表author
	CREATE TABLE IF NOT EXISTS author(
		id INT,
		au_name VARCHAR(20),
		nation VARCHAR(10)

	) 
	DESC author;


#2.表的修改

/*
语法
alter table 表名 add|drop|modify|change column 列名 【列类型 约束】;

*/

#①修改列名

	ALTER TABLE book CHANGE COLUMN publishate pubDate DATETIME;
	alter table book change column bName bookname varchar(60)
	alter table author chage column author
	alter table book change column bookname bName varchar(60)


#②修改列的类型或约束
	ALTER TABLE author MODIFY COLUMN au_name varchar(60);
	alter table author modify column nation varchar(60)
#③添加新列
	ALTER TABLE author ADD COLUMN annual DOUBLE; 

#④删除列

	ALTER TABLE author DROP COLUMN  annual;
#⑤修改表名

	ALTER TABLE author RENAME TO book_author;

	DESC book;




#3.表的删除

	DROP TABLE IF EXISTS book_author;

	SHOW TABLES;


#通用的写法：

	DROP DATABASE IF EXISTS 旧库名;
	CREATE DATABASE 新库名;


	DROP TABLE IF EXISTS 旧表名;
	CREATE TABLE  表名();



#4.表的复制
	use books
	insert into author values
	(1,'sss','ddd')

	delete from author
	TRUNCATE TABLE author
	show tables
	select * from author

	INSERT INTO author VALUES
	(1,'村上春树','日本'),
	(2,'莫言','中国'),
	(3,'冯唐','中国'),
	(4,'金庸','中国');

	SELECT * FROM author;
	SELECT * FROM copy2;
#1.仅仅复制表的结构
	show variables like "%character%"; // 查看表的结构 

	alter table `author` convert to character set utf8; // 修改表的结构 


	CREATE TABLE copy LIKE author;

#2.复制表的结构+数据

	drop table copy

	CREATE TABLE copy
	SELECT * FROM copy;

#只复制部分数据
	CREATE TABLE copy3
	SELECT id,au_name
	FROM author 
	WHERE nation='中国';

	select * from copy3
#仅仅复制某些字段
#不要值 只要字段
	CREATE TABLE copy4 
	SELECT id,au_name
	FROM author
	WHERE 0;
	select * from copy4

==========================================例题

#1. 创建表 dept1
#name Null? type
#id 			int(7)
#name 		varchar(25)

	create table dept1(
		id int(7),
		name varchar(25)
	)



#2. 将表 departments 中的数据插入新表 dept2 中
#跨越库 去插入 的 

	create table  dept2
	select department_id,department_name
	from myemployees.departments



#3. 创建表 emp5
#name 	Null?	 	type
#id					 int(7)
#First_name			 Varchar (25)
#Last_name 			Varchar(25)
#Dept_id 			int(7)

	create table emp5(
		id				 int(7),
		First_name			 Varchar (25),
		Last_name 			Varchar(25),
		Dept_id 			int(7)
	)
#4. 将列 Last_name 的长度增加到 50
	alter table emp5 modify column last_name varchar(50)	

#5. 根据表 employees 创建 employees2
	create table employees2 like myemployees.employees

#6. 删除表 emp5

	drop table if exists emp5
#7. 将表 employees2 重命名为 emp5

	alter table employees2 rename to emp5
#8 在表 dept 和 emp5 中添加新列 test_column，并检查所作的操作

	alter table emp5 add column test_column int
#9.直接删除表 emp5 中的列 dept_id

	alter table emp5 drop column test_column
118

#+END_SRC
* 数据类型
#+BEGIN_SRC 
#常见的数据类型
/*
数值型：
	整型
	小数：
		定点数
		浮点数
字符型：
	较短的文本：char、varchar
	较长的文本：text、blob（较长的二进制数据）

日期型：
	


*/

#一、整型
/*
分类：
tinyint、smallint、mediumint、int/integer、bigint
1	 2		3	4		8

特点：
① 如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字
② 如果插入的数值超出了整型的范围,会报out of range异常，并且插入临界值
③ 如果不设置长度，会有默认的长度
长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配zerofill使用！

*/

#1.如何设置无符号和有符号

DROP TABLE IF EXISTS tab_int;
CREATE TABLE tab_int(
	t1 INT(7) ZEROFILL,
	t2 INT(7) ZEROFILL 

);

DESC tab_int;


INSERT INTO tab_int VALUES(-123456);
INSERT INTO tab_int VALUES(-123456,-123456);
INSERT INTO tab_int VALUES(2147483648,4294967296);

INSERT INTO tab_int VALUES(123,123);


SELECT * FROM tab_int;


#二、小数
/*
分类：
1.浮点型
float(M,D)
double(M,D)
2.定点型
dec(M，D)
decimal(M,D)

特点：

①
M：整数部位+小数部位
D：小数部位
如果超过范围，则插入临界值

②
M和D都可以省略
如果是decimal，则M默认为10，D默认为0
如果是float和double，则会根据插入的数值的精度来决定精度

③定点型的精确度较高，如果要求插入数值的精度较高如货币运算等则考虑使用


*/
#测试M和D

DROP TABLE tab_float;
CREATE TABLE tab_float(
	f1 FLOAT,
	f2 DOUBLE,
	f3 DECIMAL
);
SELECT * FROM tab_float;
DESC tab_float;

INSERT INTO tab_float VALUES(123.4523,123.4523,123.4523);
INSERT INTO tab_float VALUES(123.456,123.456,123.456);
INSERT INTO tab_float VALUES(123.4,123.4,123.4);
INSERT INTO tab_float VALUES(1523.4,1523.4,1523.4);



#原则：
/*
所选择的类型越简单越好，能保存数值的类型越小越好

*/

#三、字符型
/*
较短的文本：

char
varchar

其他：

binary和varbinary用于保存较短的二进制
enum用于保存枚举
set用于保存集合


较长的文本：
text
blob(较大的二进制)

特点：



	写法		M的意思					特点			空间的耗费	效率
char	char(M)		最大的字符数，可以省略，默认为1		固定长度的字符		比较耗费	高

varchar varchar(M)	最大的字符数，不可以省略		可变长度的字符		比较节省	低
*/



CREATE TABLE tab_char(
	c1 ENUM('a','b','c')


);


INSERT INTO tab_char VALUES('a');
INSERT INTO tab_char VALUES('b');
INSERT INTO tab_char VALUES('c');
INSERT INTO tab_char VALUES('m');
INSERT INTO tab_char VALUES('A');

SELECT * FROM tab_set;



CREATE TABLE tab_set(

	s1 SET('a','b','c','d')



);
INSERT INTO tab_set VALUES('a');
INSERT INTO tab_set VALUES('A,B');
INSERT INTO tab_set VALUES('a,c,d');


#四、日期型

/*

分类：
date只保存日期
time 只保存时间
year只保存年

datetime保存日期+时间
timestamp保存日期+时间


特点：

		字节		范围		时区等的影响
datetime	               8		1000——9999	                  不受
timestamp	4	               1970-2038	                    受

*/


CREATE TABLE tab_date(
	t1 DATETIME,
	t2 TIMESTAMP

);



INSERT INTO tab_date VALUES(NOW(),NOW());

SELECT * FROM tab_date;


SHOW VARIABLES LIKE 'time_zone';

SET time_zone='+9:00';
#+END_SRC
* 常见约束
#+BEGIN_SRC 
#常见约束

/*


含义：一种限制，用于限制表中的数据，为了保证表中的数据的准确和可靠性


分类：六大约束
	NOT NULL：非空，用于保证该字段的值不能为空
	比如姓名、学号等
	DEFAULT:默认，用于保证该字段有默认值
	比如性别
	PRIMARY KEY:主键，用于保证该字段的值具有唯一性，并且非空
	比如学号、员工编号等
	UNIQUE:唯一，用于保证该字段的值具有唯一性，可以为空
	比如座位号
	CHECK:检查约束【mysql中不支持】
	比如年龄、性别 
	FOREIGN KEY:外键，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值
		在从表添加外键约束，用于引用主表中某列的值
	比如学生表的专业编号，员工表的部门编号，员工表的工种编号
	

添加约束的时机：
	1.创建表时
	2.修改表时
	

约束的添加分类：
	列级约束：
		六大约束语法上都支持，但外键约束没有效果
		
	表级约束：
		
		除了非空、默认，其他的都支持
		
		
主键和唯一的大对比：

		保证唯一性  是否允许为空    一个表中可以有多少个   是否允许组合
	主键	√		×		至多有1个           √，但不推荐
	唯一	√		√		可以有多个          √，但不推荐
外键：
	1、要求在从表设置外键关系
	2、从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求
	3、主表的关联列必须是一个key（一般是主键或唯一）
	4、插入数据时，先插入主表，再插入从表
	删除数据时，先删除从表，再删除主表


*/

CREATE TABLE 表名(
	字段名 字段类型 列级约束,
	字段名 字段类型,
	表级约束

)
CREATE DATABASE students;
#一、创建表时添加约束
use students
#1.添加列级约束
/*
语法：

直接在字段名和类型后面追加 约束类型即可。

只支持：默认、非空、主键、唯一



*/

USE students;
DROP TABLE stuinfo;
CREATE TABLE stuinfo(
	id INT PRIMARY KEY,#主键
	stuName VARCHAR(20) NOT NULL UNIQUE,#非空
	gender CHAR(1) CHECK(gender='男' OR gender ='女'),#检查  不支持 
	seat INT UNIQUE,#唯一   座位号 
	age INT DEFAULT  18,#默认约束   
	majorId INT REFERENCES major(id)#外键  专业名   不支持

);


CREATE TABLE major(
	id INT PRIMARY KEY,
	majorName VARCHAR(20)
);

#查看stuinfo中的所有索引，包括主键、外键、唯一
SHOW INDEX FROM stuinfo;


#2.添加表级约束
/*

语法：在各个字段的最下面
 【constraint 约束名】 约束类型(字段名) 
 
 约束名是随便起的   
*/

DROP TABLE IF EXISTS stuinfo;
CREATE TABLE stuinfo(
	id INT,
	stuname VARCHAR(20),
	gender CHAR(1),
	seat INT,
	age INT,
	majorid INT,
	
	CONSTRAINT pk PRIMARY KEY(id),#主键
	CONSTRAINT uq UNIQUE(seat),#唯一键
	CONSTRAINT ck CHECK(gender ='男' OR gender  = '女'),#检查
	CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)#外键
	
);





SHOW INDEX FROM stuinfo;



#通用的写法：★

CREATE TABLE IF NOT EXISTS stuinfo(
	id INT PRIMARY KEY,
	stuname VARCHAR(20) not null,
	sex CHAR(1),
	age INT DEFAULT 18,
	seat INT UNIQUE,
	majorid INT,
	CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)

);



#二、修改表时添加约束

/*
1、添加列级约束
alter table 表名 modify column 字段名 字段类型 新约束;

2、添加表级约束
alter table 表名 add 【constraint 约束名】 约束类型(字段名) 【外键的引用】;


*/
DROP TABLE IF EXISTS stuinfo;
CREATE TABLE stuinfo(
	id INT,
	stuname VARCHAR(20),
	gender CHAR(1),
	seat INT,
	age INT,
	majorid INT
)
DESC stuinfo;
#1.添加非空约束
ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20)  NOT NULL;
#2.添加默认约束
ALTER TABLE stuinfo MODIFY COLUMN age INT DEFAULT 18;
#3.添加主键
#①列级约束
ALTER TABLE stuinfo MODIFY COLUMN id INT PRIMARY KEY;
#②表级约束
ALTER TABLE stuinfo ADD PRIMARY KEY(id);

#4.添加唯一

#①列级约束
ALTER TABLE stuinfo MODIFY COLUMN seat INT UNIQUE;
#②表级约束
ALTER TABLE stuinfo ADD UNIQUE(seat);


#5.添加外键
ALTER TABLE stuinfo ADD CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id); 

#三、修改表时删除约束

#1.删除非空约束
ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NULL;

#2.删除默认约束
ALTER TABLE stuinfo MODIFY COLUMN age INT ;

#3.删除主键
ALTER TABLE stuinfo DROP PRIMARY KEY;

#4.删除唯一
ALTER TABLE stuinfo DROP INDEX seat;

#5.删除外键
ALTER TABLE stuinfo DROP FOREIGN KEY fk_stuinfo_major;

SHOW INDEX FROM stuinfo;


-----------------------------练习题 

#1. 向表 emp2 的 id 列中添加 PRIMARY KEY 约束（my_emp_id_pk）

	 #列添加
     alter table emp2 modify column id int primary key;
    #表添加 
	alter table emp2 add constraint my_emp_id_pk primary key(id)
    


#2. 向表 dept2 的 id 列中添加 PRIMARY KEY 约束（my_dept_id_pk）
	alter table dept2 modify column id int primary key

	alter table dep2 add constraint my_dept_id_pk primary key(id)

#3. 向表 emp2 中添加列 dept_id，并在其中定义 FOREIGN KEY 约束，与之相关联的列是
#dept2 表中的 id 列。
	alter table emp2 add column dept_id int; //添加一个 新列 
 	alter table emp2 add constraint fk_emp2_dept2 foreign key(dept_id) references dept2(id)
    
    
#+END_SRC
* 标示自增列
#+BEGIN_SRC 
#标识列
/*
又称为自增长列
含义：可以不用手动的插入值，系统提供默认的序列值
	auto_increment

特点：
1、标识列必须和主键搭配吗？不一定，但要求是一个key
2、一个表可以有几个标识列？至多一个！
3、标识列的类型只能是数值型
4、标识列可以通过 SET auto_increment_increment=3;设置步长
可以通过 手动插入值，设置起始值


*/

#一、创建表时设置标识列


DROP TABLE IF EXISTS tab_identity;
CREATE TABLE tab_identity(
	id INT  ,
	NAME FLOAT UNIQUE AUTO_INCREMENT,#自增长 
	seat INT 


);
TRUNCATE TABLE tab_identity;


INSERT INTO tab_identity(id,NAME) VALUES(NULL,'john');
INSERT INTO tab_identity(NAME) VALUES('lucy');
SELECT * FROM tab_identity;


SHOW VARIABLES LIKE '%auto_increment%';


SET auto_increment_increment=3;


#+END_SRC
* 事物
#+BEGIN_SRC 
#TCL
/*
Transaction Control Language 事务控制语言

事务：
一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行。

案例：转账

张三丰  1000
郭襄	1000

update 表 set 张三丰的余额=500 where name='张三丰'
意外
update 表 set 郭襄的余额=1500 where name='郭襄'


事务的特性：
ACID
原子性：一个事务不可再分割，要么都执行要么都不执行
一致性：一个事务执行会使数据从一个一致状态切换到另外一个一致状态
隔离性：一个事务的执行不受其他事务的干扰
持久性：一个事务一旦提交，则会永久的改变数据库的数据.



事务的创建
隐式事务：事务没有明显的开启和结束的标记
比如insert、update、delete语句

delete from 表 where id =1;

显式事务：事务具有明显的开启和结束的标记
前提：必须先设置自动提交功能为禁用

set autocommit=0;

步骤1：开启事务
set autocommit=0;
start transaction;可选的
步骤2：编写事务中的sq l语句(select insert update delete)
语句1;
语句2;
...

步骤3：结束事务
commit;提交事务
rollback;回滚事务

savepoint 节点名;设置保存点



事务的隔离级别：
		  脏读		不可重复读	幻读
read uncommitted：√		√		√
read committed：  ×		√		√
repeatable read： ×		×		√
serializable	  ×             ×               ×


mysql中默认 第三个隔离级别 repeatable read
oracle中默认第二个隔离级别 read committed
查看隔离级别
select @@tx_isolation;
设置隔离级别
set session|global transaction isolation level 隔离级别;




开启事务的语句;
update 表 set 张三丰的余额=500 where name='张三丰'

update 表 set 郭襄的余额=1500 where name='郭襄' 
结束事务的语句;



*/

SHOW VARIABLES LIKE 'autocommit';
SHOW ENGINES;

#1.演示事务的使用步骤

#开启事务
SET autocommit=0;
START TRANSACTION;
#编写一组事务的语句
UPDATE account SET balance = 1000 WHERE username='张无忌';
UPDATE account SET balance = 1000 WHERE username='赵敏';

#结束事务
ROLLBACK;
#commit;

SELECT * FROM account;


#2.演示事务对于delete和truncate的处理的区别

SET autocommit=0;
START TRANSACTION;

DELETE FROM account;
ROLLBACK;



#3.演示savepoint 的使用
SET autocommit=0;
START TRANSACTION;
DELETE FROM account WHERE id=25;
SAVEPOINT a;#设置保存点
DELETE FROM account WHERE id=28;
ROLLBACK TO a;#回滚到保存点


SELECT * FROM account;

#+END_SRC
