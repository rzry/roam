#+TITLE:     golang笔记
#+AUTHOR:    rzry
#+EMAIL:     rzry36008@ccie.lol
#+DATE:      2020-09-16
#+LANGUAGE:  en
#+OPTIONS:   H:4 num:nil toc:2
#+SETUPFILE: ../../org-html-themes/setup/theme-readtheorg.setup
#+begin_export html
<div class="right">
<a href="https://github.com/rzry" class="fa fa-github"> Edit on GitHub</a>
</div>
#+end_export
* 方法
#+BEGIN_SRC 
type Reader interface {
     Read(p []byte) (n int, err error)
}

#+END_SRC

这是  io.Reader 的定义方法   为了实现这个 io.Reader 这个接口,我们只需要实现Read方法 

关于 interface 它是一种类型 使用type关键字 interface 是具有一组方法的类型  这个方法定义了interface的行为 

interface  变量 存储的是 实现者的值  

interface  泛型编程  
#+BEGIN_SRC 
    type Interface interface { // 我们把 interface 就当做类型 他是许多类型的集合
      Len()          int     
      Less(i, j int) bool
      Swap(i, j int)
    }
    
 func Sort(data Interface) {
        n := data.Len()	   // 不管我们这边是 实现了那种方法 
        maxDepth := 0
        for i := n; i > 0; i >>= 1 {
            maxDepth++
        }
        maxDepth *= 2
        quickSort(data, 0, n, maxDepth)
    }
#+END_SRC

一个接口  可以被认为是一个 元祖  ( 类型  +  值 )   type 是接口的基础具体类型  value 是具体类型的值 
* GO 语言实战 笔记 

|1  . 下划线导入包的技术 是为了让 Go 语言对包做初始化 但是并不使用包里的标识符.Go是不允许声明导入某个包却不使用的 ,下划线让编译器接受这类导入,并且调用对用包内的所有代码文件里定义的init 函数 
|2  . 写好的都包.当被导入时,程序可以直接访问这个包中任意一个公开的标识符,标识符以大写字母开头,当然 以小写字符开头的是不会被公开的 不能被其他包中的代码直接访问.但是 也是可以间接访问的 , 例如一个函数可以返回一个未公类型的值,那么这个函数的任何调用者,哪怕调用者不是在这个包里声明的,都可以访问这个值 
|3  . make(map[string]Matcher)  map 是 Go 语言的一个引用类型,需要make 来构造.如果不先构造map,并且将构造后的值付给变量,会在师徒使用这个map 变量时收到出错信息,因为map变量默认的零值是nil. ----map的构造 会看到 map 关键词 是 make + () map[类型]+变量名
|4 . Go 中 数值类型--0  字符串---空字符串  布尔类型---false 指针---nil 
|5 . Go 中 如果main 函数返回,整个程序也就终止了,Go 程序终止是,还会关闭所有之前启动并且还在运行的Goroutine . 写并发程序时 最佳的做法是在main函数返回前,清理并终止所有之前启动的 GOroutine 
|6 . Go 语言支持闭包 因为有了闭包 , 函数可以直接访问那些没有作为参数传入的变量,函数并没有拿到这些变量的副本,而是直接访问外层函数作用域中声明的这些变量本身. 
|7 . var feeds []*Feed 我们声明了一个 名字叫 feeds 值为 nil 的切片 ,这个切片包含一组指向Feed类型值的指针  ----切片的构造  只要看到 [] 里面没东西 就是切片 var + 变量名 + []+切片类型
|8 . 定义 命名一个 接口 interface 时候, 如果接口类型只包含一个方法,那么这个类型的名字以er结尾  如果接口类型内部声明了多个方法,其名字需要与其行为关联 
|9 . 工程中存放自己写代码的位置  /PROJECT/src  存放第三方代码的位置 /PROJECT/vendor/src 
|10 . Go有三种数据结构可以让用户管理集合数据 :  数组 切片 映射 
|11 . 数组因为它占用的内存是连续分配的.由于内存连续 Cpu 才能把正在使用的数据缓存存更久的时间,而且内存很容易连续计算索引 .快速迭代数组里的所有元素 
|12 . 声明一个包含5 个元素的整形数组  var array [5]int  一旦声明.数组里存储的数据类型和数组长度就都不能改变了. Go会把定义的变量进行初始化 数组 初始化为 整形的 零值  0    -- 数组 一旦声明好之后 [8] 括号里是几 那么储存的数据类型和数组长度都不能变了 
|13 . 如果使用... 比如 arrar := [...]int{10,20,30,40} 数组的元素数量就会根据初始化时数组元素的数量来确定数组的长度   ---- [...] 这照片那个括号也是数组用的 它的目的是 长度是由初始化时候决定的
|14 . arrar := [5]*int{0: new(int),1 :  new(int)} 用整形执行很初始化索引为 0 和1 的数组元素 *arrar[0] = 10 给索引为 0 的元素赋值  
|15 . 声明 多维数组 var arrar [4][2]int 4 代表行 2 代表列 列就是一个{}里几个数字 
|16 . 切片是围绕动态数组的概念构建的 ,可以按需自动增长和缩小,切片的动态增长是通过内置函数 append 来实现的 定义切片  make  silce := make([]string,5) 定义一个字符串切片 容量长度都是5  slice := make([]int , 3,5 ) 创建一个整形切片 长度为3 容量为5 
|17  . 如果在[]运算符中 指定了一个值 比如 [4]string 那么就是数组 不是切片了 只有在不指定值的时候才会创建切片 
|18. 创建一个nil切片  var slice []int   Go语言中 nil切片是种很常见的创建切片的方法 ; 
|19 . 使用切片,用[操作符] 就能改变某个元素的值  切片 slice[i: j;k] 长度 j-i 容量 k-i
|20 . 设置长度和容量一样的好处 长度和容量一样的话 后面新切片会拥有自己的底层数组,所以杜绝了影响之前切片的可能 也为了保持切片申请新的底层数组的简洁  (******) 这算是一个 小问题
|21 .迭代切片  range 可以配合关键字 for 来迭代切片里的元素   range的第二个值是每个元素的副本 而不是直接返回对该元素的引用 , 所以 使用该值变量的地址作为指向每个元素的指针,就会造成错误 
|22 . 多维切片 声明的时候也是没差别的 slice := [][]int{} 什么垃圾键盘 还是我自己输入法的问题 
|23 . map 映射 映射是一种数据结构,用于存储一系列无序的键值对  映射所强大的是能够基于键快速检索数据,键就像索引一样 指向与该键关联的值 
|24 . 映射是一个集合,可以使用类似处理数组和切片的方式迭代映射中的元素,但是映射是无序的集合.所以没有办法预测键值对被返回的顺序,无序的原因是 映射的实现使用了散列表 
|25 . 使用make 创建映射  dict := make(map[string]int) 使用两个键值对初始化映射  dict := map[string]string{"Red": "#da1337", "Orange": "#e95a22"}   声明一个存储字符串切片的映射  创建一个映射 使用字符串切片作为值  dict := map[int][]string{} 到今天我才懂  映射一共写两个类型 第一个类型是 位置 第二个类型是 值  
|26 . 创建一个空映射 colors := map[string]string{} 然后可以通过 colors["Red"] = "#da1337" 这样添加  但是nil 映射不能存储键值对 var colors map[string]string  这就是nil映射  他没有{} 花括号  -----  nil 映射没有花括号 
|27 . 可以存映射获取值 并判断值是否存在
#+BEGIN_SRC 
   // 获取键 Blue 对应的值
     value := colors["Blue"]
     // 这个键存在吗？
     if value != "" {
     fmt.Println(value)
     }	
#+END_SRC   
|28 . range可以 range   map 然后 range返回的不是索引和值.而是键值对 想要删除一个键值对 使用delete 函数 这种方法只能在映射储存的都是非零值的情况下 
|29 . make 可以创建 切片和映射 切片有容量限制,不过可以使用append 函数扩展容量  映射 map 的增加没有容量或者任何限制 函数 cap 只能用于切片 代表容量     
|30 . 通过组合 可以创建多维数组和多维切片   (*****) 也可以使用切片或者其他作为映射的值,但是切片不能用作映射的键 就是 不能一上来就 map切片 不能当做键 可以做值  切片或者映射传递给函数成本很小,并且不会复制底层的数据结构 
|31 . 用户自定义的类型  .. (***) 这算是一个难点,,, 结构体 struct 结构类型通过组合一系列固定且唯一的字段来声明,结构里每个字段都会用一个已知的类型声明  
#+BEGIN_SRC 
   01 // user 在程序里定义一个用户类型
   02 type user struct { // type 关键字 新类型的名字 关键字struct
   03 name string      
   04 email string
   05 ext int
   06 privileged bool
   07 }
  定义之后 再 声明 就可以使用了  var bill user 这样 这个bill 的类型就是 user
#+END_SRC 
|32 . 方法 , 方法能够给用户定义的类型添加新的行为 .  方法实际上也是函数 只是在声明时,在关键字func 和方法名之间增加一个参数  比如: 我们之前定义了一个 user 的类型  然后我们可以使用 notify 进行值接受实现一个方法  func(u user) notify(){ } ...func和函数名之间的参数被称作接受者 , 将函数与接受者的类型绑在一起,如果一个函数有接受者 那么这个函数就被称为方法 ... 
|     func(u user) notify(){   }   我们来解析一下这个  func 之后接了一个() 这个() 里面的参数称作 接受者  然后就是 函数名 nitify  他就被用作值的接受者     
|33 . Go 语言中有两种类型的接受者.值接受者和指针接受者 
|     33.1 . func (u user) notify() {  } 值接受者 
|     33.2 . func (u *user) changeEmail(email string) {  } 指针接受者	
|      notify 方法的接受者被声明为user 类型的值 如果使用值接受者声明方法 调用时会使用这个值的一个副本来执行, 调用这个notify 方法的时候 bill := user{"Bill", "bill@email.com"}    bill.notify()   先声明了一个 user 类型的变量 bill  初始化之后 再使用变量 bill 调用 notify 方法  
|34 . 使用变量调用方法 bill.notify()  在调用notify 方法时候 使用bill 的值作为接受者进行调用 方法notify 会接受到bill 的值的一个副本 
|指针接受的时候 差别就是  方法的接受者应该使用指针类型  u *user 在调用的时候 应该 把指针解引用为值  再次强调  notify操作的只是一个副本 只不过指针接受的时候 是  从 lisa 指针指向的值的副本 
|35 . 在声明一个新类型之后,声明一个该类型的方法之前,我们要知道 如果要创建一个新值,该类型的方法就是用值接受者, 如果是要修改当前值,就是用指针接受者.
|36 . 实现 . 接口是用来定义行为的类型.这些被定义的行为不由接口直接实现,而是通过方法由用户定义的类型实现 , 
|37 . 并发 和并行  如果两个线程 共用一个核 使用一个逻辑处理器 那么 这个 线程就会并发进行 而并行 是 使用了多个逻辑处理器 
|38 . 关于竞争状态.两个或者多个线程在没有互相同步的情况下,访问某个共享的资源,并且同时读 写 这个资源就竞争了 而 在我们 mysql 中 提出 原子化的概念 
|39 . 加锁 mysql里面不是也有  共享锁 互斥锁 我们GOlang 中使用 atomic 和 sync 包的函数  atomic.AddInt64(&counter, 1) 加锁... 就ok了
|40 . golang 加锁叫做 原子函数 atmoic sync  loadint64 storeint64
|41 . 互斥锁 .  代码在创建一个临界区 保证同一时间只有一个 goroutine  
|42 . Go 的并发同步逻辑来自一个叫做 CSP 范型  通信顺讯进程  .这种数据的类型叫做 通道 channel 
|43 . 无缓存的channel  eg2 中 ball,ok := <- court 阻塞了 然后在 court <- 将数据给了管道
