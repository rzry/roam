#+TITLE:     go并发之道
#+AUTHOR:    rzry https://github.com/rzry
#+EMAIL:     rzry36008@ccie.lol
#+DATE:      2021-01-12
#+LANGUAGE:  en

* TODO note

  - 最好不要让goroutine 异步调用
    #+BEGIN_SRC go
      func Server(){
              go func(){
                      println()
              }()

      }

      func Server(){
              println
      }

      go Server()
    #+END_SRC
  - 使用chan 来控制你创建的goroutine
   #+BEGIN_SRC go
    func init(){

     }

     func main(){
             done := make(chan error,2)
             stop := make(chan struct{},0)

             go func(){

             }()
     }

     func debug(){
     }

     func handler(){

     }

     func service(){

     }
   #+END_SRC

* DONE part 1
  CLOSED: [2021-01-22 五 01:10]
  - 竞争条件
    #+begin_src go
    // TestA ...
    func TestA(t *testing.T)  {
            var data int
            go func(){data++}()

            if data == 0{
                    t.Log("this value is ",data)
            }
    }
    //1 . 什么都不打印 data++ 在if 前
    //2 . 打印0 if  在data++ 之前执行
    //3 . 打印1 data++在if之后执行 但是log在data++后执行
    // 哪怕在if 前加sleep 也只是降低了这种可能性
    // 并不会是一个健康的程序
    #+end_src
  - 内存访问同步
    #+begin_src go
      // TestA ...
      func TestA(t *testing.T)  {
              var data int
              go func(){data++}()
              if data == 0{
                      t.Log("this value is ",data)
              }else{
                      t.Log("this value is ",data)
              }
      }
      // data 算是 共享资源 . 对上述例子有三个临界区
      //临界区是需要独占访问共享资源
      // 1 . goroutine 在让data++
      // 2 . if 在检查data 是否为0
      // 3 . t.log 正在检索并打印data 的值
    #+end_src
    #+begin_src go
      func TestA(t *testing.T)  {
              var memoryAccess sync.Mutex
              var value int
              go func (){
                      memoryAccess.Lock()
                      value++
                      memoryAccess.Unlock()
              }()

              memoryAccess.Lock()
              if value == 0{
                      t.Log("this value is ",value)
              }else{
                      t.Log("this value is ",value)
              }
              memory.Access.Unlock()

      }
      //...虽然并不会这样做,但是这可以简单演示内存访问同步
      // 声明一个锁 , 直到锁取消前 goroutine 应该独占内存的访问权
      // unlock 宣布goroutine使用完这段内存
      // 再声明下面的 判断语句,让它独占data内存的访问权
      // 虽然这样解决了数据竞争,但是并没有它的操作顺序是不确定的
      // 上述代码,goroutine喝if/else 都会有可能先执行
      // 并且上述加锁会有性能问题,lock 会让我们程序变慢
      // --ques
      // 临界区是否频繁出入
      // 临界区该有多大 .. context
    #+end_src

  - 死锁
    #+begin_src go
      type Value struct {
              mu sync.Mutex
              value int
      }

      func TestA(t *testing.T){
              var wg sync.WaitGroup

              printSum := func(v1,v2 *Value){
                      defer wg.Done()

                      v1.mu.Lock()
                      defer v1.mu.Unlock()

                      time.Sleep(2*time.Second)
                      v2.mu.Lock()
                      defer v2.mu.Unlock()
                      t.Logf("sum = %v",v1.value+v2.value)
              }
              var a ,b Value
              wg.Add(2)
              go printSum(&a,&b)
              go printSum(&b,&a)
              wg.Wait()
      }
      // 第一个 go 调用 函数 锁定a 然后等待2s 准备锁定b
      // 第二个 go 开始锁定b 然后在试着锁定 a
      // 两步同时进行,无限等待
    #+end_src
  - 活锁
    #+begin_src go
    
    #+end_src
  - 饥饿
    #+begin_src go
      func TestGo(t *testing.T){
              var wg sync.WaitGroup
              var sharedLock sync.Mutex
              const runtime = 1*time.Second

              greedyWorker := func(){
                      defer wg.Done()
                      var count int
                      for begin := time.Now();time.Since(begin) <= runtime;{
                              sharedLock.Lock()
                              time.Sleep(3*time.Nanosecond)
                              sharedLock.Unlock()
                              count++
                      }
                      t.Logf("贪心work execute %v",count)
              }

              politeWorker := func(){
                      defer wg.Done()
                      var count int
                      for begin := time.Now();time.Since(begin)<= runtime;{

                              sharedLock.Lock()
                              time.Sleep(1*time.Nanosecond)
                              sharedLock.Unlock()

                              sharedLock.Lock()
                              time.Sleep(1*time.Nanosecond)
                              sharedLock.Unlock()

                              sharedLock.Lock()
                              time.Sleep(1*time.Nanosecond)
                              sharedLock.Unlock()

                              count++
                      }
                      t.Logf("平和 work execute %v",count)
              }

              wg.Add(2)
              go greedyWorker()
              go politeWorker()
              wg.Wait()
      }
      // 贪婪的 count 值大 
      // 两个程序 共享锁, 贪婪的work 会贪婪的抢占
      // 平和的worker 只会在需要时锁定
      // 两个人工作同样的工作,同样的时间,贪婪的工作量
      // 是平和的work 的两倍
      // 不知道可不可以理解为 每次加锁越多 就会越慢 要等待别人释放
    #+end_src
* DONE part 2 
  CLOSED: [2021-01-22 五 01:30]
  - 并发or并行
    #+begin_src 
    1 . 并发属于代码,并行属于程序
    2 . csp 如果在 sync 和 channel 作出选择
      - 传递数据所有权(类似生产消费)-->带缓存的channel来做
      - 保护结构的内部状态,想要内部数据线程安全--> sync 
      - 协调多个逻辑片段--> select,channel 
        因为channel本质上比内存访问同步原语更具有组合性
      - 性能...
    3 . 追求简洁.尽量使用channel 并且认为goroutine没有成本
    #+end_src
* TODO part 3
  - goroutine 
    #+begin_src 
    1 . go中的goroutine是独一无二的
    2 . 不是os线程,也不是绿色线程(语言运行时管理的线程)
    3 . 它们是协程(非抢占式,简单并发子goroutine(函数,闭包,方法))
    4 . 他们可以在被阻塞时挂起,不阻塞时恢复.某种程度它们又称为可抢占的
    5 . 协程和goroutine都是隐式并发结构,但是并发不是协程的属性
        必须同时托管多个协程,并给每个协程一个可以执行的机会,
        否则他们就不会并发,(但是go 协程并不是隐式并行的)
    #+end_src
  - go的主机托管机制
    #+begin_src 
    1 . 主机托管机制是,M:N 调度器实现的,M个绿色线程映射到N个OS线程
        然后将goroutine运行在绿色线程.
    2 . 当goroutine数量超过可用绿色线程的时候
        调度程序将处理分布在可用线程上的goroutine
        并且确保当这些goroutine被阻塞时,其他的goroutine可以运行      
    #+end_src
-------
下接 page 49 fork-join
